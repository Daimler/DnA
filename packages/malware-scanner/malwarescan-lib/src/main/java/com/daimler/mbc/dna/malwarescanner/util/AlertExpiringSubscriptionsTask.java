package com.daimler.mbc.dna.malwarescanner.util;

import com.daimler.data.dto.solution.ChangeLogVO;
import com.daimler.dna.notifications.common.producer.KafkaProducerService;
import com.daimler.mbc.dna.malwarescanner.dto.appsubscription.SubscriptionVO;
import com.daimler.mbc.dna.malwarescanner.service.appsubscription.AppSubscriptionService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.concurrent.TimeUnit;

@Slf4j
@Component
public class AlertExpiringSubscriptionsTask {

	@Autowired
	private AppSubscriptionService appSubscriptionService;
	
	@Value("${task.alert.before-expiry-duration}")
	private String alertBeforeExpiryDay;
	
	//@Value("${dna.system.adminName}")
	private String dnaSystemAdminName = "DNA-System-Admin";

	//@Value("${task.alert.subscriptionExpiryEventName}")
	private String eventType = "Malware-Expiry-Alert";
		
	@Autowired
	private KafkaProducerService kafkaProducer;
	
	 @Scheduled(cron = "0 0 0 * * *")
	public void alertExpirySubscriptions() {
		 long diff;
		 try {
			Calendar calendar = Calendar.getInstance();
			calendar.setTime(new Date());
			Date today = calendar.getTime();
			calendar.add(Calendar.DATE, Integer.parseInt(alertBeforeExpiryDay)); 
			DateFormat simple = new SimpleDateFormat("dd MMM yyyy HH:mm:ss");
			Date maxExpiryDate = calendar.getTime();
			List<SubscriptionVO> subscriptions = appSubscriptionService.getAllWithFilters("", true, ConstantsUtility.OPEN, null, "appName", "asc", 0, 0, null);
			if(subscriptions!= null && !subscriptions.isEmpty()) {
				log.info("Got all subscritions which are in open state, to scan for subscriptions that are about to be expired in {} number of days."
						+ " Total open subscriptions are {} ", alertBeforeExpiryDay, subscriptions.size());
				for(SubscriptionVO subscription: subscriptions) {
					Date expiryDate = subscription.getExpireOn();
					if(expiryDate!= null && expiryDate.compareTo(maxExpiryDate) <= 0) {
						 diff = today.getTime() - expiryDate.getTime();
						String message = "Your malware subscription for application " + subscription.getAppName() + " already expired "
								+ TimeUnit.DAYS.convert(diff, TimeUnit.MILLISECONDS) + " days, on date " + simple.format(expiryDate);
						String logMessage = "max expiry datetime is : " + maxExpiryDate.getTime() + " subscription expiry datetime is : " + expiryDate.getTime() + " difference is : " + diff + " difference in days is : " + TimeUnit.DAYS.convert(diff, TimeUnit.MILLISECONDS);
						log.info(logMessage);						
						boolean mailRequired = true;
						List<String> subscribedUsers = new ArrayList<>();
						subscribedUsers.add(subscription.getCreatedBy());
						List<String> subscribedUsersEmail = new ArrayList<>();
						List<ChangeLogVO> changeLogs = null;
						String resourceId = subscription.getAppId();
						kafkaProducer.send(eventType,resourceId , "", dnaSystemAdminName, message, mailRequired, subscribedUsers,subscribedUsersEmail,changeLogs);
						log.info("Published event to alert upcoming subscription expiry for appName {} ", subscription.getAppName());
					} else if (expiryDate!=null && expiryDate.compareTo(maxExpiryDate) > 0) {
						// fixed alert message if it greater then zero
						diff= expiryDate.getTime() - today.getTime();
						String message = "your malware subscription for application " + subscription.getAppName() + " is going to expire in "
								+ TimeUnit.DAYS.convert(diff, TimeUnit.MILLISECONDS) + " days, on date " + simple.format(expiryDate);
						String logMessage = "max expiry datetime is : " + maxExpiryDate.getTime() + " subscription expiry datetime is : " + expiryDate.getTime() + " difference is : " + diff + " difference in days is : " + TimeUnit.DAYS.convert(diff, TimeUnit.MILLISECONDS);
						log.info(logMessage);
						boolean mailRequired = true;
						List<String> subscribedUsers = new ArrayList<>();
						subscribedUsers.add(subscription.getCreatedBy());
						List<String> subscribedUsersEmail = new ArrayList<>();
						List<ChangeLogVO> changeLogs = null;
						String resourceId = subscription.getAppId();
						kafkaProducer.send(eventType,resourceId , "", dnaSystemAdminName, message, mailRequired, subscribedUsers,subscribedUsersEmail,changeLogs);

					}
				}
			}
		 }catch(Exception e) {
			 log.error("Error occuried while fetching subscriptions to notifying creator about expiring subscriptions");
		 }
	}
	
	
}
